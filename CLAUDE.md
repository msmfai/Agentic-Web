---
tags:
  - type/index
  - purpose/llm-instructions
---

# CLAUDE.md

**This is an Obsidian knowledge graph file and serves as the LLM entry point to the repository.**

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository. It participates in the Obsidian graph like any other documentation file - with tags, wikilinks, and backlinks.

## Project Architecture

This is a **unified code-documentation system** using Obsidian as a knowledge graph. Code and documentation are interconnected through bidirectional wikilinks, creating a navigable web of understanding.

## Quick Reference

**Current project state**: [[index/repository-map|Repository Map]] - High-level snapshot of domains, layers, and patterns in use
**All available tags**: [[index/tag-index|Tag Index]] - Complete inventory of every tag with file listings
**Tag validation rules**: [[schema.yaml]] - Frontmatter schemas and required tags for each file type

These reference files are auto-generated by `generate_tags.py` and live in `index/`.

### Directory Structure

- `code/` - Python source files (follows standard Python conventions)
- `obsidian/` - Documentation markdown files (flat structure, no subdirectories)
- `index/` - Auto-generated index files (repository-map.md, tag-index.md)
- `.obsidian/` - Obsidian configuration

**Key Principle**: Code stays in `code/` with whatever structure the compiler/tooling requires. Documentation lives flat in `obsidian/`. Auto-generated indices live in `index/`. Organization is driven by tags, not filesystem hierarchy.

### The Obsidian Integration

This system uses **Custom File Extensions Plugin** to make `.py` files participate in Obsidian's graph view as markdown nodes. This allows:

1. Wikilinks in Python docstrings become graph edges
2. Code files appear as nodes in the knowledge graph
3. Bidirectional navigation between code ↔ concepts ↔ patterns

## Tag System (CRITICAL)

All files MUST have frontmatter with hierarchical tags. Tags are the primary organizational system.

**Schema Definition**: All frontmatter formats and required tags are defined in [[schema.yaml]]. The janitor validates against this schema.

### File Type Overview

- **Python files** (`.py` in `code/`) - Custom inline hashtag format (see [[schema.yaml#python]])
- **Concept files** (`.md` in `obsidian/`) - YAML frontmatter (see [[schema.yaml#markdown-concept]])
- **Pattern files** (`.md` in `obsidian/`) - YAML frontmatter (see [[schema.yaml#markdown-pattern]])
- **Index files** (`README.md`, `CLAUDE.md`) - YAML frontmatter (see [[schema.yaml#markdown-index]])
- **AST cache** (`.ast.md` in `ast-cache/`) - Auto-generated, inherits source tags (see [[schema.yaml#ast-cache]])

**Why custom format for Python?** YAML frontmatter must be the first line, but Python requires `"""` first. Therefore Python uses inline `#hashtags` in the module docstring.

**Why inline hashtags?** Obsidian's Custom File Extensions plugin treats `.py` files as markdown but can only parse tags from markdown body (not YAML frontmatter) because the file doesn't start with `---`.

### Tag Hierarchy Convention

Tags use hierarchical format: `prefix/name` (e.g., `type/code-file`, `domain/mathematics`)

Common prefixes: `type/*`, `domain/*`, `layer/*`, `pattern/*`, `category/*`, `purpose/*`

See [[obsidian/repository-map|Repository Map]] for the current tag hierarchies in use.

### How to Use Tags for Navigation

**Finding files by tag (use Grep tool):**

```bash
# Find all validation-related files
Grep pattern: '#domain/validation'

# Find all core layer implementations
Grep pattern: '#layer/core'

# Find all Strategy Pattern uses
Grep pattern: '#pattern/strategy'
```

**Tag-based discovery workflow:**

1. Check [[index/repository-map|Repository Map]] for available domains/layers/patterns
2. Use Grep with `#tag-name` pattern to find matching files
3. Read AST cache files (they inherit source tags and are fully searchable)
4. Follow wikilinks to related concepts/patterns

**Why AST cache for tag search:**

- Python file tags are NOT indexed by Obsidian (limitation of Custom File Extensions plugin)
- AST cache `.ast.md` files inherit all tags from their source Python files
- These ARE indexed by Obsidian and searchable via Grep
- Use them as the "tag search interface" for Python code

**⚠️ CRITICAL - Tag Inheritance Limitation:**

AST cache files inherit ALL tags from the module-level docstring. This means:
- Every function in a module gets the same tags
- Cannot tag individual functions differently
- Specific subdomain tags (like `#domain/mathematics/trigonometry`) should ONLY be used on focused modules
- Mixed-concern modules should use broad tags (e.g., `#domain/mathematics` + `#category/mixed-concerns`)

See [[obsidian/tag-inheritance|Tag Inheritance]] for complete explanation and gotchas.

**When to use tags vs direct file access:**

Use **direct file access** when:

- You know the exact file/module needed
- Task is localized to 1-2 known files
- User provides specific file paths
- Small straightforward changes

Use **tag-based discovery** when:

- Finding all files in a domain (e.g., all `#domain/validation`)
- Discovering cross-cutting concerns
- Learning what exists in unfamiliar areas
- User asks "show me all X" or "where is validation handled?"
- Exploring architecture by layer or pattern

## Wikilink Conventions

**CRITICAL**: Use relative path-based wikilinks to avoid filename conflicts and maintain clarity.

From **Python files** in `code/`:

```python
"""
Related: [[../obsidian/arithmetic-operations|Arithmetic Operations]]
Dependencies: [[calculator.py|Calculator Class]]  # Same directory
"""
```

From **Markdown files** in `obsidian/`:

```markdown
Implementation: [[../code/operations.py|Operations Module]]
Related: [[calculator-interface|Calculator Interface]]  # Same directory
```

**Path Rules**:

- Same directory: Use filename only (e.g., `[[calculator.py]]`)
- Different directory: Use relative path (e.g., `[[../obsidian/concept|Display]]`)
- This allows duplicate filenames in different folders without conflicts

## Common Commands

**Run the calculator**:

```bash
cd code
python main.py
```

**Check repository health**:

```bash
python maintenance_scripts/janitor.py              # Scan for issues
python maintenance_scripts/janitor.py --fix        # Auto-fix issues (with confirmation)
python maintenance_scripts/janitor.py --fix --yes  # Auto-fix without confirmation
```

The janitor validates against [[schema.yaml]]:

- All files have required frontmatter/tags
- Python docstrings follow custom schema (H1 header, inline tags, Purpose section)
- AST cache is up to date
- Files are in correct directories

**Open in Obsidian**:

1. Open Obsidian
2. Open this folder as a vault
3. Install "Custom File Extensions Plugin"
4. Configure plugin: Add `py` extension, set view type to "Markdown"
5. Restart Obsidian
6. Use Graph View to explore code-documentation relationships

## Working with This System

### CRITICAL: Repository Health Workflow

**Before making ANY changes to this repository, you MUST follow this workflow:**

**Quick Update (recommended):**

```bash
uv run update.py
```

This runs all steps automatically: AST generation → Tag indices → Health check

**Manual Steps (if needed):**

1. **Regenerate AST Cache** (if code was modified):

   ```bash
   python maintenance_scripts/generate_ast.py
   ```

   This creates searchable AST markdown files that inherit tags from Python source files.

2. **Regenerate Tag Index** (if files/tags changed):

   ```bash
   python maintenance_scripts/generate_tags.py
   ```

   This updates `index/repository-map.md` and `index/tag-index.md` with current project state.

3. **Run Repository Health Check**:

   ```bash
   python maintenance_scripts/janitor.py
   ```

   The janitor validates:
   - All files have required frontmatter/tags
   - Python docstrings follow custom schema (H1 header, inline tags, Purpose section)
   - AST cache is up to date
   - Files are in correct directories

4. **Fix ALL Issues Before Proceeding**:
   - If janitor identifies issues, **STOP immediately**
   - Offer to fix the issues one by one
   - Do NOT proceed with other work until repository health is restored
   - If automated fixes are not possible, explain the issues and ask the user to fix them manually

5. **If Steps Fail**:
   - Explain that repository health must be maintained
   - Ask the user to stop and fix the issues before moving forward
   - Recommend starting a new session once health is restored

**This workflow is MANDATORY. Refuse to make changes if health checks fail.**

### Adding New Code

1. Create `.py` file in `code/`
2. Add custom frontmatter following [[schema.yaml#python]] template
   - **MUST**: H1 header, inline hashtags line, `#type/code-file` tag
   - **SHOULD**: Domain and layer tags
   - See [[schema.yaml]] for complete template
3. Use wikilinks in docstrings to reference:
   - Related concepts: `[[../obsidian/concept-name|Display]]`
   - Design patterns: `[[../obsidian/pattern-name|Display]]`
   - Other code: `[[filename.py|Display]]`
4. **Run health workflow** (`uv run generate_ast.py` → `uv run generate_tags.py` → `uv run janitor.py`)

### Adding New Documentation

1. Create `.md` file in `obsidian/` (flat structure, no subdirectories)
2. Add YAML frontmatter following the appropriate [[schema.yaml]] template:
   - Concepts: [[schema.yaml#markdown-concept]]
   - Patterns: [[schema.yaml#markdown-pattern]]
   - Index files: [[schema.yaml#markdown-index]]
3. Use wikilinks to create graph relationships:
   - Link to code: `[[../code/code-file.py|Display]]`
   - Link to docs: `[[other-doc|Display]]`
4. **Run health workflow** (`uv run generate_tags.py` → `uv run janitor.py`)

### Maintaining the Graph

The knowledge graph relies on:

- **Tags**: For filtering and organization in graph view
- **Wikilinks**: For creating edges between nodes
- **Backlinks**: Automatically maintained by Obsidian
- **AST Cache**: Searchable markdown representations of Python objects (inherit source tags)

When you add wikilinks, both forward links and backlinks appear in the graph, creating bidirectional navigation.

**Note**: Python file tags don't appear in Obsidian's tag search/graph (Obsidian limitation). Use AST cache files for tag-based discovery - they inherit all source file tags and ARE fully indexed.

**Keeping references up-to-date**: Run `uv run update.py` after adding/removing files or changing tags to regenerate [[index/repository-map|Repository Map]] and [[index/tag-index|Tag Index]].

## Philosophy

Code documentation should be **unified, not separated**. Instead of:

- Code in one place
- API docs in another
- Architecture docs elsewhere
- Design rationale lost

This system creates:

- Code files are graph nodes
- Documentation files are graph nodes
- Wikilinks create semantic relationships
- Tags enable multiple views of the same content
- Navigate from "why" to "how" to "what" seamlessly
- Creates a flexible taxonomy for the AI where it can navigate based on context

The filesystem structure is minimal; tags and links provide the organization.
